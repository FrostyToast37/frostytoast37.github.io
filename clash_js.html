<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>AI Clash v1.5</title>
<style>
    /* --- MAIN MENU & UI STYLES --- */
    body {
      background-color: #333;
      font-family: 'Arial', sans-serif;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      overflow: hidden;
      margin: 0;
    }
    #app-container {
      width: 400px;
      height: 700px;
      position: relative;
    }
    #main-menu-page, #game-page, #deck-page {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
    }
    #main-menu-page {
      background: linear-gradient(135deg, rgba(0,0,0,0.8), rgba(20,40,60,0.95));
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      text-align: center;
      color: #fff;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
      border: 4px solid #4a3c2a;
      border-radius: 10px;
      box-sizing: border-box;
    }
    #main-menu-page h1 {
      font-size: 48px;
      margin: 0 0 40px 0;
      font-weight: bold;
    }
    .main-menu-button {
      background: linear-gradient(#ffcc00, #e6b800);
      color: #000;
      border: none;
      padding: 15px 40px;
      font-size: 22px;
      font-weight: bold;
      border-radius: 25px;
      cursor: pointer;
      box-shadow: 0 4px 8px rgba(0,0,0,0.3);
      transition: transform 0.1s, box-shadow 0.1s;
      width: 200px;
      margin-bottom: 20px;
    }
    .main-menu-button:hover {
      transform: scale(1.05);
      box-shadow: 0 6px 12px rgba(0,0,0,0.4);
    }
    .main-menu-button:active {
      transform: scale(0.98);
    }
    /* Deck Page Styles */
    #deck-page {
      background: linear-gradient(135deg, rgba(0,0,0,0.8), rgba(20,40,60,0.95));
      display: flex;
      flex-direction: column;
      align-items: center;
      color: #fff;
      padding: 20px;
      box-sizing: border-box;
      overflow-y: auto;
    }
    #deck-page h2 {
      font-size: 32px;
      margin-bottom: 20px;
    }
    #deck-cards-container {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
    }
    .deck-card {
      width: 65px;
      height: 90px;
      background: white;
      border: 3px solid #fdd835;
      border-radius: 8px;
      cursor: pointer;
      position: relative;
      display: flex;
      flex-direction: column;
      justify-content: flex-end;
      align-items: center;
      padding: 0;
      box-sizing: border-box;
      font-weight: bold;
      text-align: center;
      overflow: hidden;
      margin: 5px;
    }
    .deck-card.selected {
      border-color: #00ff00;
    }
    #save-deck-button {
      margin-top: 20px;
      background: linear-gradient(#ffcc00, #e6b800);
      color: #000;
      border: none;
      padding: 10px 20px;
      font-size: 18px;
      font-weight: bold;
      border-radius: 25px;
      cursor: pointer;
    }
    .hidden {
      display: none !important;
    }

    /* --- GAME CSS --- */
    #game-container {
      position: relative;
      width: 100%;
      height: 100%;
      background: #5a8c3d;
      border: 4px solid #4a3c2a;
      border-radius: 10px;
      overflow: hidden;
      box-sizing: border-box;
    }
    #battlefield {
      width: 100%;
      height: calc(100% - 150px);
      position: relative;
      overflow: hidden;
    }
    /* Screen Shake Animation */
    .shake-effect {
      animation: shake 0.4s cubic-bezier(.36,.07,.19,.97) both;
      transform: translate3d(0, 0, 0);
      backface-visibility: hidden;
    }
    @keyframes shake {
      10%, 90% { transform: translate3d(-2px, 0, 0); }
      20%, 80% { transform: translate3d(4px, 0, 0); }
      30%, 50%, 70% { transform: translate3d(-6px, 0, 0); }
      40%, 60% { transform: translate3d(6px, 0, 0); }
    }

    /* Full Screen Flash for Lightning */
    #flash-overlay {
      position: absolute;
      top: 0; left: 0; width: 100%; height: 100%;
      background: white;
      opacity: 0;
      pointer-events: none;
      z-index: 200;
      transition: opacity 0.1s;
    }
    #flash-overlay.active {
      opacity: 0.6;
    }

    #river {
      position: absolute;
      width: 100%;
      height: 50px;
      background: #4a9dbe;
      top: 50%;
      transform: translateY(-50%);
      z-index: 1;
    }
    .bridge {
      position: absolute;
      width: 60px;
      height: 50px;
      background: #a17b4d;
      border-left: 5px solid #735836;
      border-right: 5px solid #735836;
      top: 50%;
      transform: translateY(-50%);
      z-index: 2;
    }
    #bridge-left { left: 40px; }
    #bridge-right { right: 40px; }
    
    .tower {
      position: absolute;
      width: 60px;
      height: 80px;
      background: #c9c9c9;
      border: 4px solid #777;
      border-radius: 5px 5px 0 0;
      z-index: 3;
      display: flex;
      justify-content: center;
      padding-top: 10px;
      box-sizing: border-box;
    }
    .tower::after {
      content: '';
      position: absolute;
      top: -12px;
      width: 70px;
      height: 20px;
      background: #a33e3e;
      border: 4px solid #777;
      border-radius: 5px;
    }
    .player-king { bottom: 20px; left: 50%; transform: translateX(-50%); }
    .player-princess { bottom: 60px; }
    #player-p1 { left: 40px; }
    #player-p2 { right: 40px; }
    .enemy-king { top: 20px; left: 50%; transform: translateX(-50%); }
    .enemy-princess { top: 60px; }
    #enemy-p1 { left: 40px; }
    #enemy-p2 { right: 40px; }

    #elixir-bar-container {
      position: absolute;
      bottom: 110px;
      width: 80%;
      left: 10%;
      height: 20px;
      background: #222;
      border-radius: 10px;
      border: 2px solid #555;
      overflow: hidden;
    }
    #elixir-bar {
      width: 50%;
      height: 100%;
      background: linear-gradient(to right, #e040fb, #aa00ff);
      transition: width 0.2s linear;
    }
    #elixir-count {
      position: absolute;
      top: 0;
      left: 50%;
      transform: translateX(-50%);
      color: white;
      font-weight: bold;
      line-height: 20px;
      text-shadow: 1px 1px 2px black;
    }
    #card-tray {
      position: absolute;
      bottom: 0;
      width: 100%;
      height: 100px;
      background: #4a3c2a;
      display: flex;
      justify-content: space-around;
      align-items: center;
      padding: 5px;
      box-sizing: border-box;
    }
    .card {
      width: 65px;
      height: 90px;
      background: white;
      border: 3px solid #fdd835;
      border-radius: 8px;
      cursor: grab;
      position: relative;
      display: flex;
      flex-direction: column;
      justify-content: flex-end;
      align-items: center;
      padding: 0;
      box-sizing: border-box;
      font-weight: bold;
      text-align: center;
      overflow: hidden;
    }
    .card:active {
      cursor: grabbing;
      border-color: #ff0000;
    }
    .card-cost {
      position: absolute;
      top: 2px;
      left: 4px;
      font-size: 14px;
      font-weight: bold;
      background: rgba(170, 0, 255, 0.8);
      border: 2px solid rgba(255, 255, 255, 0.5);
      border-radius: 50%;
      width: 20px;
      height: 20px;
      line-height: 20px;
      text-align: center;
      color: white;
      z-index: 2;
    }
    .card-image {
      position: absolute;
      top: -5px;
      left: -15%;
      width: 130%;
      height: auto;
      z-index: 1;
      pointer-events: none;
    }
    .card-name {
      font-size: 10px;
      z-index: 2;
      background: rgba(0, 0, 0, 0.6);
      color: white;
      width: 100%;
      padding: 2px 0;
      box-sizing: border-box;
    }
    .troop {
      position: absolute;
      width: 40px;
      height: 40px;
      object-fit: contain;
      z-index: 10;
      pointer-events: none;
    }
    
    /* HEALTH BARS & FLASHING */
    .health-bar-container {
      position: absolute;
      width: 50px;
      height: 6px;
      background-color: #333;
      border: 1px solid black;
      border-radius: 3px;
      z-index: 11;
      transition: transform 0.1s;
    }
    .health-bar-current {
      height: 100%;
      width: 100%;
      background-color: #f44336;
      border-radius: 2px;
      transition: background-color 0.1s;
    }
    .health-bar-current.player { background-color: #4CAF50; }
    
    .troop-health-bar {
      position: absolute;
      width: 30px;
      height: 4px;
      background-color: #333;
      border: 1px solid black;
      border-radius: 2px;
      z-index: 11;
    }
    .troop-health-bar-current {
      height: 100%;
      width: 100%;
      border-radius: 1px;
      transition: background-color 0.1s;
    }
    .troop-health-bar-current.player { background-color: #4CAF50; }
    .troop-health-bar-current.ai { background-color: #f44336; }

    .hit-flash {
      background-color: #ffffff !important;
      box-shadow: 0 0 5px #fff;
    }

    /* --- ENHANCED ANIMATIONS --- */
    .projectile {
      position: absolute;
      z-index: 100;
      pointer-events: none;
      transform-origin: center;
    }
    
    .spell-effect {
      position: absolute;
      pointer-events: none;
      z-index: 90;
      transform: translate(-50%, -50%);
    }

    /* FIREBALL */
    .fireball-explosion {
      width: 200px;
      height: 200px;
      background: radial-gradient(circle, #fff 0%, #ffeb3b 20%, #ff5722 50%, transparent 80%);
      border-radius: 50%;
      animation: explode 0.4s ease-out forwards;
      box-shadow: 0 0 50px rgba(255, 87, 34, 0.8);
      z-index: 120;
    }
    @keyframes explode {
      0% { transform: translate(-50%, -50%) scale(0.1); opacity: 1; }
      100% { transform: translate(-50%, -50%) scale(1.3); opacity: 0; }
    }

    /* ARROWS RAIN */
    .arrows-area {
      width: 240px;
      height: 240px;
      background: rgba(0, 0, 0, 0.1);
      border-radius: 50%;
      animation: fadeOut 0.8s ease-out forwards;
      overflow: visible;
    }
    .mini-arrow {
      position: absolute;
      width: 2px;
      height: 20px;
      background: #5d4037;
      top: -80px;
      animation: dropArrow 0.4s linear forwards;
    }
    .mini-arrow:after {
      content: '';
      position: absolute;
      bottom: -3px; left: -2px;
      width: 0; height: 0;
      border-left: 3px solid transparent;
      border-right: 3px solid transparent;
      border-top: 6px solid #fff;
    }
    @keyframes dropArrow {
      0% { transform: translateY(0); opacity: 0; }
      20% { opacity: 1; }
      100% { transform: translateY(150px); opacity: 0; }
    }
    @keyframes fadeOut {
      0% { opacity: 1; }
      100% { opacity: 0; }
    }
    
    /* LIGHTNING */
    .lightning-bolt {
      width: 15px;
      height: 400px;
      background: #fff;
      box-shadow: 0 0 20px #00ffff, 0 0 40px #0000ff;
      transform-origin: bottom center;
      animation: lightningStrike 0.2s linear forwards;
      z-index: 120;
    }
    @keyframes lightningStrike {
      0% { opacity: 0; height: 0; }
      10% { opacity: 1; height: 400px; }
      40% { opacity: 1; width: 25px; } 
      100% { opacity: 0; width: 0px; }
    }

    #stat-overlay {
      position: absolute;
      bottom: 105px;
      left: 10px;
      width: calc(100% - 20px);
      background: rgba(0, 0, 0, 0.85);
      border: 2px solid #fdd835;
      border-radius: 8px;
      padding: 10px;
      color: white;
      z-index: 20;
      display: none;
      box-sizing: border-box;
      pointer-events: none;
    }
    #stat-overlay.visible { display: block; }
    #stat-overlay h3 { margin: 0 0 5px 0; color: #fdd835; font-size: 16px; }
    #stat-overlay p { margin: 4px 0; font-size: 12px; }

    .no-deploy-zone {
      position: absolute;
      top: 0;
      height: 245px;
      background: rgba(255, 0, 0, 0.4);
      z-index: 5;
      display: none;
      pointer-events: none;
    }
    #no-deploy-zone-left { left: 0; width: 50%; }
    #no-deploy-zone-right { left: 50%; width: 50%; }
    .no-deploy-zone.visible { display: block; }
    #no-deploy-zone-king { top: 20px; left: 170px; width: 60px; height: 80px; }

    #game-menu, #game-over-menu {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: linear-gradient(135deg, rgba(0,0,0,0.8), rgba(20,40,60,0.95));
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 999;
    }
    .menu-content { text-align: center; color: #fff; text-shadow: 2px 2px 4px rgba(0,0,0,0.8); }
    .menu-content h1 { font-size: 32px; margin: 0 0 10px 0; font-weight: bold; }
    .menu-content p { font-size: 18px; margin: 0 0 20px 0; }
    #play-button, #play-again-button {
      background: linear-gradient(#ffcc00, #e6b800);
      color: #000;
      border: none;
      padding: 15px 40px;
      font-size: 22px;
      font-weight: bold;
      border-radius: 25px;
      cursor: pointer;
      box-shadow: 0 4px 8px rgba(0,0,0,0.3);
      transition: transform 0.1s, box-shadow 0.1s;
    }
    #play-button:hover, #play-again-button:hover { transform: scale(1.05); box-shadow: 0 6px 12px rgba(0,0,0,0.4); }
    #play-button:active, #play-again-button:active { transform: scale(0.98); }
</style>
</head>
<body>

  <div id="app-container">
    <div id="main-menu-page">
      <h1>AI Clash</h1>
      <button id="main-menu-play-button" class="main-menu-button">Play</button>
      <button id="main-menu-deck-button" class="main-menu-button">Deck</button>
    </div>
    <div id="deck-page" class="hidden">
      <h2>Select Your Deck (8 Cards)</h2>
      <div id="deck-cards-container"></div>
      <button id="save-deck-button">Save Deck</button>
    </div>
    <div id="game-page" class="hidden">
      <div id="game-container">
        <div id="flash-overlay"></div>

        <div id="game-menu">
          <div class="menu-content">
            <h1>AI Clash</h1>
            <p>Defeat the enemy King to win!</p>
            <button id="play-button">Play</button>
          </div>
        </div>
     
        <div id="game-over-menu" style="display: none;">
          <div class="menu-content">
            <h1 id="result-title">Victory!</h1>
            <p id="result-text">Enemy King Destroyed!</p>
            <button id="play-again-button">Play Again</button>
          </div>
        </div>
     
        <div id="battlefield">
          <div class="no-deploy-zone" id="no-deploy-zone-left"></div>
          <div class="no-deploy-zone" id="no-deploy-zone-right"></div>
          <div class="no-deploy-zone" id="no-deploy-zone-king"></div>
       
          <div class="tower enemy-king" id="enemy-king"></div>
          <div class="tower enemy-princess" id="enemy-p1"></div>
          <div class="tower enemy-princess" id="enemy-p2"></div>
       
          <div id="river"></div>
          <div class="bridge" id="bridge-left"></div>
          <div class="bridge" id="bridge-right"></div>
       
          <div class="tower player-king" id="player-king"></div>
          <div class="tower player-princess" id="player-p1"></div>
          <div class="tower player-princess" id="player-p2"></div>
        </div>
     
        <div id="elixir-bar-container">
          <div id="elixir-bar"></div>
          <span id="elixir-count">5</span>
        </div>
     
        <div id="stat-overlay">
        </div>
     
        <div id="card-tray">
        </div>
      </div>
    </div>
  </div>

<script>
    window.onload = function() {
      // --- MENU LOGIC ---
      const mainMenuPage = document.getElementById('main-menu-page');
      const gamePage = document.getElementById('game-page');
      const deckPage = document.getElementById('deck-page');
      const mainMenuPlayButton = document.getElementById('main-menu-play-button');
      const mainMenuDeckButton = document.getElementById('main-menu-deck-button');
      const saveDeckButton = document.getElementById('save-deck-button');
      
      if (mainMenuPlayButton) {
        mainMenuPlayButton.addEventListener('click', () => {
          mainMenuPage.classList.add('hidden');
          gamePage.classList.remove('hidden');
        });
      }
      if (mainMenuDeckButton) {
        mainMenuDeckButton.addEventListener('click', () => {
          mainMenuPage.classList.add('hidden');
          deckPage.classList.remove('hidden');
        });
      }
      if (saveDeckButton) {
        saveDeckButton.addEventListener('click', () => {
          localStorage.setItem('selectedDeck', JSON.stringify(selectedDeck));
          deckPage.classList.add('hidden');
          mainMenuPage.classList.remove('hidden');
        });
      }
      
      const gameMenu = document.getElementById('game-menu');
      const playButton = document.getElementById('play-button');
      const gameOverMenu = document.getElementById('game-over-menu');
      const playAgainButton = document.getElementById('play-again-button');
     
      if (playButton) playButton.addEventListener('click', startGame);
      if (gameOverMenu && playAgainButton) {
        playAgainButton.addEventListener('click', () => location.reload());
      }

      // --- GAME VARIABLES ---
      const battlefield = document.getElementById('battlefield');
      const cardTray = document.getElementById('card-tray');
      const elixirBar = document.getElementById('elixir-bar');
      const elixirCount = document.getElementById('elixir-count');
      const statOverlay = document.getElementById('stat-overlay');
      const flashOverlay = document.getElementById('flash-overlay');
      const noDeployLeft = document.getElementById('no-deploy-zone-left');
      const noDeployRight = document.getElementById('no-deploy-zone-right');
      const noDeployKing = document.getElementById('no-deploy-zone-king');

      const CARD_DATA = {
        Knight: { type: 'troop', cost: 3, imageUrl: 'https://i.postimg.cc/qM5Cfg8Z/download.jpg', speed: 0.6, health: 660, damage: 75, attackSpeed: 70, range: 10, targetType: 'any', attackType: 'ground', count: 1, isFlying: false },
        Archer: { type: 'troop', cost: 3, imageUrl: 'https://i.postimg.cc/1XWV33bS/download-(1).jpg', speed: 0.5, health: 120, damage: 40, attackSpeed: 60, range: 100, targetType: 'any', attackType: 'airAndGround', count: 2, isFlying: false, projectileType: 'arrow' },
        Giant: { type: 'troop', cost: 5, imageUrl: 'https://i.postimg.cc/3xkmW28w/download-(2).jpg', speed: 0.3, health: 1500, damage: 100, attackSpeed: 90, range: 10, targetType: 'buildings', attackType: 'ground', count: 1, isFlying: false },
        Musketeer: { type: 'troop', cost: 4, imageUrl: 'https://i.postimg.cc/TP4R1WPX/download-(8).jpg', speed: 0.5, health: 300, damage: 90, attackSpeed: 60, range: 120, targetType: 'any', attackType: 'airAndGround', count: 1, isFlying: false, projectileType: 'bullet' },
        MiniPekka: { type: 'troop', cost: 4, imageUrl: 'https://i.postimg.cc/d3JG0X1j/download-(4).jpg', speed: 0.7, health: 500, damage: 250, attackSpeed: 100, range: 10, targetType: 'any', attackType: 'ground', count: 1, isFlying: false },
        Goblins: { type: 'troop', cost: 2, imageUrl: 'https://i.postimg.cc/XYPKgQHf/download-(5).jpg', speed: 0.9, health: 80, damage: 45, attackSpeed: 40, range: 10, targetType: 'any', attackType: 'ground', count: 4, isFlying: false },
        Valkyrie: { type: 'troop', cost: 4, imageUrl: 'https://i.postimg.cc/9FWBX4w5/download-(6).jpg', speed: 0.6, health: 700, damage: 100, attackSpeed: 80, range: 10, targetType: 'any', attackType: 'ground', count: 1, isFlying: false },
        BabyDragon: { type: 'troop', cost: 4, imageUrl: 'https://i.postimg.cc/KjGHB0jc/download-(7).jpg', speed: 0.5, health: 600, damage: 60, attackSpeed: 70, range: 80, targetType: 'any', attackType: 'airAndGround', count: 1, isFlying: true, projectileType: 'fireball_small' },
        Minions: { type: 'troop', cost: 3, imageUrl: 'https://i.postimg.cc/bvfQphyq/download-(9).jpg', speed: 0.8, health: 90, damage: 40, attackSpeed: 50, range: 20, targetType: 'any', attackType: 'airAndGround', count: 3, isFlying: true, projectileType: 'dark_elixir' },
        
        // --- BUFFED CANNON: More Health, Faster Attack, Longer Range ---
        Cannon: { type: 'building', cost: 3, imageUrl: 'https://i.postimg.cc/pT1W2d53/download-1.jpg', speed: 0, health: 450, damage: 70, attackSpeed: 40, range: 115, targetType: 'any', attackType: 'ground', count: 1, isFlying: false, projectileType: 'cannonball' },
        
        // --- NERFED HUT: Slower Spawn Rate (2.5s) ---
        GoblinHut: { type: 'building', cost: 5, imageUrl: 'https://i.postimg.cc/26y7064Q/download-2.jpg', speed: 0, health: 800, damage: 0, attackSpeed: 0, range: 0, targetType: 'none', attackType: 'none', count: 1, isFlying: false, spawnUnit: 'SpearGoblins', spawnRate: 2500 },
        
        SpearGoblins: { type: 'troop', cost: 2, imageUrl: 'https://i.postimg.cc/0j1tL2y2/download-3.jpg', speed: 0.85, health: 52, damage: 24, attackSpeed: 50, range: 100, targetType: 'any', attackType: 'airAndGround', count: 3, isFlying: false, projectileType: 'spear' },
        
        // --- NERFED SKELETONS: Lower Health ---
        SkeletonArmy: { type: 'troop', cost: 3, imageUrl: 'https://i.postimg.cc/Rh4v644q/download-4.jpg', speed: 0.9, health: 20, damage: 32, attackSpeed: 40, range: 10, targetType: 'any', attackType: 'ground', count: 25, isFlying: false },
        
        Fireball: { type: 'spell', cost: 4, imageUrl: 'https://i.postimg.cc/8Psdb4Xk/download-(10).jpg', damage: 200, radius: 80, targetAir: true, targetGround: true, spellEffect: 'fireball' },
        Arrows: { type: 'spell', cost: 3, imageUrl: 'https://i.postimg.cc/C5rGgn1m/download-(11).jpg', damage: 100, radius: 120, targetAir: true, targetGround: true, spellEffect: 'arrows' },
        Lightning: { type: 'spell', cost: 6, imageUrl: 'https://i.postimg.cc/8CLm6CKF/download-(12).jpg', damage: 300, radius: 100, maxTargets: 3, targetAir: true, targetGround: true, spellEffect: 'lightning' },
      };

      const allCardNames = Object.keys(CARD_DATA);
      let selectedDeck = ['Knight', 'Archer', 'Giant', 'Cannon', 'SpearGoblins', 'SkeletonArmy', 'GoblinHut', 'BabyDragon'];
      const savedDeck = localStorage.getItem('selectedDeck');
      if (savedDeck) selectedDeck = JSON.parse(savedDeck);

      function populateDeckSelection() {
        const container = document.getElementById('deck-cards-container');
        container.innerHTML = '';
        allCardNames.forEach(name => {
          const card = createCardElement(name, true);
          if (selectedDeck.includes(name)) card.classList.add('selected');
          card.addEventListener('click', () => {
            if (card.classList.contains('selected')) {
              card.classList.remove('selected');
              selectedDeck = selectedDeck.filter(n => n !== name);
            } else if (selectedDeck.length < 8) {
              card.classList.add('selected');
              selectedDeck.push(name);
            }
          });
          container.appendChild(card);
        });
      }
      populateDeckSelection();

      // --- Game State ---
      let currentElixir = 5;
      let aiElixir = 5;
      const maxElixir = 10;
      const elixirRegenRate = 2000;
      let draggedCardData = null;
      let activeTroops = [];
      let towerObjects = {};
      const aiDeck = ['Knight', 'Archer', 'Giant', 'SkeletonArmy', 'Musketeer', 'BabyDragon', 'Minions', 'Arrows'];
      let gameRunning = false;
      let elixirInterval = null;
      let aiInterval = null;

      const ARENA_WIDTH = 400;
      const RIVER_Y = 245;
      const BRIDGE_LEFT_X = 70;
      const BRIDGE_RIGHT_X = 330;
      const PLAYER_TOWER_LEFT_X = 40;
      const PLAYER_TOWER_RIGHT_X = 300;
      const PLAYER_TOWER_Y = 400;
      const PLAYER_KING_X = 170;
      const PLAYER_KING_Y = 460;
      const ENEMY_TOWER_LEFT_X = 40;
      const ENEMY_TOWER_RIGHT_X = 300;
      const ENEMY_TOWER_Y = 60;
      const ENEMY_KING_X = 170;
      const ENEMY_KING_Y = 20;

      function updateElixirDisplay() {
        elixirCount.textContent = Math.floor(currentElixir);
        elixirBar.style.width = `${(currentElixir / maxElixir) * 100}%`;
      }

      function getSpeedCategory(speed) {
        if (speed === 0) return 'Stationary';
        if (speed < 0.4) return 'Slow';
        if (speed < 0.6) return 'Medium';
        if (speed < 0.8) return 'Fast';
        return 'Very Fast';
      }

      function getDistance(unitA, unitB) {
        const ax = unitA._x || unitA.x;
        const ay = unitA._y || unitA.y;
        const bx = unitB._x || unitB.x;
        const by = unitB._y || unitB.y;
        return Math.sqrt((ax - bx)**2 + (ay - by)**2);
      }

      function createCardElement(name, forDeck = false) {
        const data = CARD_DATA[name];
        if (!data) return;
        const card = document.createElement('div');
        card.classList.add(forDeck ? 'deck-card' : 'card');
        card.dataset.name = name;
        card.dataset.cost = data.cost;
        card.draggable = !forDeck;
        const nameSpan = document.createElement('span');
        nameSpan.classList.add('card-name');
        nameSpan.textContent = name;
        const costSpan = document.createElement('span');
        costSpan.classList.add('card-cost');
        costSpan.textContent = data.cost;
        const img = document.createElement('img');
        img.src = data.imageUrl;
        img.classList.add('card-image');
        card.appendChild(img);
        card.appendChild(nameSpan);
        card.appendChild(costSpan);
        return card;
      }

      function populateCardTray() {
        cardTray.innerHTML = '';
        selectedDeck.forEach(name => {
          const card = createCardElement(name);
          card.addEventListener('dragstart', (e) => {
            if (!gameRunning) return;
            const cardName = e.target.dataset.name;
            const data = CARD_DATA[cardName];
            if (data.type !== 'spell') {
              if (!towerObjects['enemy-p1'].isDead) noDeployLeft.classList.add('visible');
              if (!towerObjects['enemy-p2'].isDead) noDeployRight.classList.add('visible');
              noDeployKing.classList.add('visible');
            }
            draggedCardData = { name: cardName, cost: parseInt(e.target.dataset.cost, 10) };
            e.dataTransfer.setData('text/plain', name);
          });
          card.addEventListener('dragend', (e) => {
            noDeployLeft.classList.remove('visible');
            noDeployRight.classList.remove('visible');
            noDeployKing.classList.remove('visible');
          });
          card.addEventListener('mouseover', (e) => {
            const cardName = e.currentTarget.dataset.name;
            const data = CARD_DATA[cardName];
            statOverlay.innerHTML = `<h3>${cardName}</h3><p><b>Health:</b> ${data.health||'N/A'}</p><p><b>Damage:</b> ${data.damage||'N/A'}</p><p><b>Speed:</b> ${getSpeedCategory(data.speed)||'N/A'}</p>`;
            statOverlay.classList.add('visible');
          });
          card.addEventListener('mouseout', () => statOverlay.classList.remove('visible'));
          cardTray.appendChild(card);
        });
      }

      battlefield.addEventListener('dragover', (e) => e.preventDefault());
      battlefield.addEventListener('drop', (e) => {
        e.preventDefault();
        noDeployLeft.classList.remove('visible');
        noDeployRight.classList.remove('visible');
        noDeployKing.classList.remove('visible');
        if (!gameRunning || !draggedCardData) return;
        const data = CARD_DATA[draggedCardData.name];
        if (currentElixir >= draggedCardData.cost) {
          const rect = battlefield.getBoundingClientRect();
          const x = e.clientX - rect.left;
          const y = e.clientY - rect.top;
          let isOverTower = false;
          Object.values(towerObjects).forEach(t => {
            if (!t.isDead && x >= t.x && x <= t.x+60 && y >= t.y && y <= t.y+80) isOverTower = true;
          });
          if (isOverTower && data.type !== 'spell') {
            console.warn('Cannot deploy troops on a Tower!'); draggedCardData = null; return;
          }
          const isLeftLane = x < ARENA_WIDTH / 2;
          const isEnemyTerritory = y < RIVER_Y;
          let canDeploy = true;
          // Buildings behave like troops for deployment zones
          if ((data.type === 'troop' || data.type === 'building') && isEnemyTerritory) {
            if (isLeftLane && !towerObjects['enemy-p1'].isDead) canDeploy = false;
            else if (!isLeftLane && !towerObjects['enemy-p2'].isDead) canDeploy = false;
          }
          if (canDeploy) {
            currentElixir -= draggedCardData.cost;
            updateElixirDisplay();
            if (data.type === 'troop' || data.type === 'building') deployTroop(draggedCardData.name, x, y, 'player');
            else if (data.type === 'spell') applySpell(draggedCardData.name, x, y);
          } else { console.warn('Cannot deploy there!'); }
        } else { console.warn('Not enough elixir!'); }
        draggedCardData = null;
      });

      // --- ANIMATION HELPERS ---

      function triggerShake() {
        battlefield.classList.remove('shake-effect');
        void battlefield.offsetWidth; // Trigger reflow
        battlefield.classList.add('shake-effect');
      }

      function triggerFlash() {
        flashOverlay.classList.add('active');
        setTimeout(() => {
          flashOverlay.classList.remove('active');
        }, 150);
      }

      function triggerSpellVisual(type, x, y) {
        const visual = document.createElement('div');
        visual.className = 'spell-effect';
        visual.style.left = `${x}px`;
        visual.style.top = `${y}px`;
        
        if (type === 'fireball') {
          visual.classList.add('fireball-explosion');
          triggerShake();
        } else if (type === 'arrows') {
          visual.classList.add('arrows-area');
          for(let i=0; i<50; i++) {
            const arrow = document.createElement('div');
            arrow.className = 'mini-arrow';
            const rx = (Math.random() - 0.5) * 160;
            const ry = (Math.random() - 0.5) * 160;
            arrow.style.left = `${120 + rx}px`;
            arrow.style.top = `${120 + ry}px`;
            arrow.style.animationDelay = `${Math.random() * 0.4}s`;
            visual.appendChild(arrow);
          }
        } else if (type === 'lightning') {
          visual.classList.add('lightning-bolt');
          visual.style.top = `${y - 200}px`; 
          triggerFlash();
          triggerShake();
        }

        battlefield.appendChild(visual);
        setTimeout(() => visual.remove(), 800);
      }

      function triggerProjectile(startUnit, targetUnit, type) {
        const projectile = document.createElement('div');
        projectile.className = 'projectile';
        
        let width = 5, height = 5, color = 'black';
        let isRound = false;
        
        if (type === 'arrow') {
            width = 15; height = 3; color = '#8B4513';
            projectile.style.borderRadius = '0 50% 50% 0';
        } else if (type === 'spear') {
            width = 18; height = 2; color = '#D2691E'; // Thinner, lighter brown for spears
        } else if (type === 'cannonball') {
            width = 10; height = 10; color = '#111';
            isRound = true;
        } else if (type === 'fireball_small') {
            width = 12; height = 12; color = 'orange';
            isRound = true;
        } else if (type === 'bullet') {
            width = 6; height = 6; color = '#222';
            isRound = true;
        } else if (type === 'dark_elixir') {
            width = 14; height = 14; 
            projectile.style.background = 'radial-gradient(circle, #D8BFD8 0%, #4B0082 100%)';
            projectile.style.boxShadow = '0 0 6px #8A2BE2';
            isRound = true;
        } else {
            projectile.style.background = 'black';
        }

        if (isRound) projectile.style.borderRadius = '50%';
        if (!type.includes('dark_elixir')) projectile.style.background = color;

        projectile.style.width = `${width}px`;
        projectile.style.height = `${height}px`;

        const startX = startUnit._x;
        const startY = startUnit._y;
        const targetX = targetUnit._x;
        const targetY = targetUnit._y;
        
        const angle = Math.atan2(targetY - startY, targetX - startX) * (180 / Math.PI);
        projectile.style.transform = `rotate(${angle}deg)`;

        battlefield.appendChild(projectile);

        const animation = projectile.animate([
            { left: `${startX}px`, top: `${startY}px` },
            { left: `${targetX}px`, top: `${targetY}px` }
        ], {
            duration: 300, 
            easing: 'linear'
        });

        animation.onfinish = () => {
            projectile.remove();
        };
      }


      function applySpell(spellName, x, y) {
        const data = CARD_DATA[spellName];
        if (!data) return;

        if (spellName === 'Fireball' || spellName === 'Arrows') {
           triggerSpellVisual(data.spellEffect, x, y);
        }

        const targets = [...activeTroops, ...Object.values(towerObjects)].filter(unit => !unit.isDead);
        const inRange = targets.filter(unit => getDistance({ _x: x, _y: y }, unit) <= data.radius 
          && ((data.targetGround && !unit.isFlying) || (data.targetAir && unit.isFlying) || (!unit.isFlying && !('isFlying' in unit))));
        
        if (spellName === 'Lightning') {
          inRange.sort((a, b) => b.currentHealth - a.currentHealth);
          const hitTargets = inRange.slice(0, data.maxTargets);
          hitTargets.forEach(target => {
            triggerSpellVisual('lightning', target._x, target._y);
            target.currentHealth -= data.damage;
            updateHealthBar(target);
            checkDeath(target);
          });
        } else {
          setTimeout(() => {
              inRange.forEach(target => {
                target.currentHealth -= data.damage;
                updateHealthBar(target);
                checkDeath(target);
              });
          }, 250);
        }
      }

      function updateHealthBar(unit) {
        const healthPercent = (unit.currentHealth / unit.maxHealth) * 100;
        unit.healthBar.style.width = `${Math.max(0, healthPercent)}%`;
        unit.healthBar.classList.add('hit-flash');
        setTimeout(() => {
            unit.healthBar.classList.remove('hit-flash');
        }, 100);
      }

      function checkDeath(unit) {
        if (unit.currentHealth <= 0 && !unit.isDead) {
          unit.isDead = true;
          if (unit.element) unit.element.style.display = 'none';
          if (unit.healthBarContainer) unit.healthBarContainer.style.display = 'none';
          if (unit.id && unit.id.includes('-king')) endGame(unit.faction === 'ai' ? 'You Win!' : 'You Lose!');
        }
      }

      function initializeTowers() {
        const towerElements = [
          { id: 'enemy-p1', faction: 'ai', element: document.getElementById('enemy-p1'), x: ENEMY_TOWER_LEFT_X, y: ENEMY_TOWER_Y, maxHealth: 1400, currentHealth: 1400, damage: 50, range: 150, attackSpeed: 60, attackType: 'airAndGround' },
          { id: 'enemy-p2', faction: 'ai', element: document.getElementById('enemy-p2'), x: ENEMY_TOWER_RIGHT_X, y: ENEMY_TOWER_Y, maxHealth: 1400, currentHealth: 1400, damage: 50, range: 150, attackSpeed: 60, attackType: 'airAndGround' },
          { id: 'enemy-king', faction: 'ai', element: document.getElementById('enemy-king'), x: ENEMY_KING_X, y: ENEMY_KING_Y, maxHealth: 2400, currentHealth: 2400, damage: 60, range: 130, attackSpeed: 70, attackType: 'airAndGround' },
          { id: 'player-p1', faction: 'player', element: document.getElementById('player-p1'), x: PLAYER_TOWER_LEFT_X, y: PLAYER_TOWER_Y, maxHealth: 1400, currentHealth: 1400, damage: 50, range: 150, attackSpeed: 60, attackType: 'airAndGround' },
          { id: 'player-p2', faction: 'player', element: document.getElementById('player-p2'), x: PLAYER_TOWER_RIGHT_X, y: PLAYER_TOWER_Y, maxHealth: 1400, currentHealth: 1400, damage: 50, range: 150, attackSpeed: 60, attackType: 'airAndGround' },
          { id: 'player-king', faction: 'player', element: document.getElementById('player-king'), x: PLAYER_KING_X, y: PLAYER_KING_Y, maxHealth: 2400, currentHealth: 2400, damage: 60, range: 130, attackSpeed: 70, attackType: 'airAndGround' },
        ];
        towerElements.forEach((towerData) => {
          const healthBarContainer = document.createElement('div');
          healthBarContainer.className = 'health-bar-container';
          healthBarContainer.style.left = `${towerData.x + 5}px`;
          healthBarContainer.style.top = `${towerData.y - 15}px`;
          const healthBarCurrent = document.createElement('div');
          healthBarCurrent.className = `health-bar-current ${towerData.faction}`;
          healthBarContainer.appendChild(healthBarCurrent);
          battlefield.appendChild(healthBarContainer);
          towerObjects[towerData.id] = { ...towerData, _x: towerData.x + 30, _y: towerData.y + 40, healthBar: healthBarCurrent, healthBarContainer: healthBarContainer, isDead: false, attackCooldown: 0, currentTarget: null };
        });
      }

      function deployTroop(cardName, x, y, faction, countOverride = null) {
        const data = CARD_DATA[cardName];
        if (!data) return;
        
        // Use override if provided (for huts spawning 1 unit), otherwise use card default
        const count = countOverride !== null ? countOverride : data.count;

        for (let i = 0; i < count; i++) {
          // Add random jitter for swarms so they don't stack perfectly
          const jitterX = (Math.random() - 0.5) * 20; 
          const jitterY = (Math.random() - 0.5) * 20;
          
          let startX = x - 20 + jitterX;
          let startY = y - 20 + jitterY;
          
          // Formations for small counts (keeps existing logic somewhat)
          if (count < 5 && count > 1) {
             const offsetX = (i - Math.floor(count / 2)) * 10;
             const offsetY = i % 2 * 10;
             startX = x - 20 + offsetX;
             startY = y - 20 + offsetY;
          }

          const troopElement = document.createElement('img');
          troopElement.classList.add('troop');
          troopElement.src = data.imageUrl;
          troopElement.style.left = `${startX}px`;
          troopElement.style.top = `${startY}px`;
          const healthBarContainer = document.createElement('div');
          healthBarContainer.className = 'troop-health-bar';
          healthBarContainer.style.left = `${startX + 5}px`;
          healthBarContainer.style.top = `${startY - 8}px`;
          const healthBarCurrent = document.createElement('div');
          healthBarCurrent.className = `troop-health-bar-current ${faction}`;
          healthBarContainer.appendChild(healthBarCurrent);
          let defaultTargetTower, finalTarget;
          if (faction === 'player') {
            finalTarget = towerObjects['enemy-king'];
            defaultTargetTower = x < ARENA_WIDTH / 2 ? towerObjects['enemy-p1'] : towerObjects['enemy-p2'];
          } else {
            finalTarget = towerObjects['player-king'];
            defaultTargetTower = x < ARENA_WIDTH / 2 ? towerObjects['player-p1'] : towerObjects['player-p2'];
          }
          battlefield.appendChild(troopElement);
          battlefield.appendChild(healthBarContainer);
          const troop = {
            ...data, cardName: cardName, element: troopElement, faction: faction, x: startX, y: startY, _x: startX + 20, _y: startY + 20,
            attackCooldown: 0, maxHealth: data.health, currentHealth: data.health, healthBar: healthBarCurrent, healthBarContainer: healthBarContainer,
            isDead: false, currentTarget: null, defaultTargetTower: defaultTargetTower, finalTarget: finalTarget,
            // Spawner specific properties
            lastSpawnTime: Date.now() 
          };
          activeTroops.push(troop);
        }
      }

      function findNewTarget(troop) {
        const enemyFaction = troop.faction === 'player' ? 'ai' : 'player';
        const enemyPrefix = troop.faction === 'player' ? 'enemy' : 'player';
        let closestTarget = null;
        let minDistance = 9999;
        
        // Building-only targeters (Giant) ignore troops
        if (troop.targetType === 'buildings') {
          let targets = [towerObjects[`${enemyPrefix}-p1`], towerObjects[`${enemyPrefix}-p2`], towerObjects[`${enemyPrefix}-king`]];
          // Also check for enemy buildings (Cannon, Hut) in activeTroops
          for (const t of activeTroops) {
              if (t.faction === enemyFaction && !t.isDead && t.type === 'building') {
                  targets.push(t);
              }
          }
          for (const tower of targets) {
            if (tower && !tower.isDead) {
              const dist = getDistance(troop, tower);
              if (dist < minDistance) { minDistance = dist; closestTarget = tower; }
            }
          }
          troop.currentTarget = closestTarget;
          return;
        }

        // Standard troops
        for (const t of activeTroops) {
          if (t.faction === enemyFaction && !t.isDead) {
            if (t.isFlying && troop.attackType === 'ground') continue;
            const dist = getDistance(troop, t);
            if (dist < minDistance) { minDistance = dist; closestTarget = t; }
          }
        }
        let targets = [towerObjects[`${enemyPrefix}-p1`], towerObjects[`${enemyPrefix}-p2`], towerObjects[`${enemyPrefix}-king`]];
        for (const tower of targets) {
          if (tower && !tower.isDead) {
            const dist = getDistance(troop, tower);
            if (dist < minDistance) { minDistance = dist; closestTarget = tower; }
          }
        }
        troop.currentTarget = closestTarget;
      }

      function resetGame() {
        gameRunning = false;
        if (elixirInterval) clearInterval(elixirInterval);
        if (aiInterval) clearInterval(aiInterval);
        elixirInterval = null; aiInterval = null;
        activeTroops.forEach(troop => { troop.element.remove(); troop.healthBarContainer.remove(); });
        activeTroops = [];
        Object.values(towerObjects).forEach(tower => { if (tower.healthBarContainer) tower.healthBarContainer.remove(); });
        towerObjects = {};
        currentElixir = 5; aiElixir = 5;
      }

      function endGame(message) {
        gameRunning = false;
        if (elixirInterval) clearInterval(elixirInterval);
        if (aiInterval) clearInterval(aiInterval);
        const resultTitle = document.getElementById('result-title');
        const resultText = document.getElementById('result-text');
        document.getElementById('game-over-menu').style.display = 'flex';
        resultTitle.textContent = message === 'You Win!' ? 'Victory!' : 'Defeat!';
        resultText.textContent = message === 'You Win!' ? 'Enemy King Destroyed!' : 'Your King Destroyed!';
        resetGame();
      }

      function startGame() {
        gameRunning = true;
        gameMenu.style.display = 'none';
        updateElixirDisplay();
        populateCardTray();
        initializeTowers();
        elixirInterval = setInterval(() => {
          if (!gameRunning) return;
          if (currentElixir < maxElixir) { currentElixir += 1; if (currentElixir > maxElixir) currentElixir = maxElixir; updateElixirDisplay(); }
          if (aiElixir < maxElixir) { aiElixir += 1; if (aiElixir > maxElixir) aiElixir = maxElixir; }
        }, elixirRegenRate);
        aiInterval = setInterval(() => {
          if (!gameRunning) return;
          const cardName = aiDeck[Math.floor(Math.random() * aiDeck.length)];
          const data = CARD_DATA[cardName];
          if (aiElixir >= data.cost) {
            aiElixir -= data.cost;
            let deployX = Math.random() > 0.5 ? 100 : 300;
            if (data.type === 'troop' || data.type === 'building') deployTroop(cardName, deployX, 120, 'ai');
            else if (data.type === 'spell') applySpell(cardName, Math.random() > 0.5 ? 100 : 300, 400);
          }
        }, 3000);
        gameLoop();
      }

      function gameLoop() {
        if (!gameRunning) return;
        
        for (let i = activeTroops.length - 1; i >= 0; i--) {
          const troop = activeTroops[i];
          if (troop.isDead) {
            troop.element.remove();
            troop.healthBarContainer.remove();
            activeTroops.splice(i, 1);
          }
        }

        for (const troop of activeTroops) {
          
          // --- SPAWNER LOGIC (Goblin Hut) ---
          if (troop.spawnUnit && !troop.isDead) {
              const now = Date.now();
              if (now - troop.lastSpawnTime > troop.spawnRate) {
                  // Spawn 1 unit at hut location
                  deployTroop(troop.spawnUnit, troop.x, troop.y, troop.faction, 1);
                  troop.lastSpawnTime = now;
              }
          }

          if (!troop.currentTarget || troop.currentTarget.isDead) {
            findNewTarget(troop);
          }
          
          // Even if no target, stationary buildings don't move.
          // If we have a target, check range.
          const finalTarget = troop.currentTarget;
          let distance = 9999;
          if (finalTarget) distance = getDistance(troop, finalTarget);
          
          // MOVE only if distance > range AND speed > 0
          if (finalTarget && distance > troop.range && troop.speed > 0) {
            let moveTarget = finalTarget;
            const needsToCross = (troop.faction === 'player' && finalTarget._y < RIVER_Y && troop._y > RIVER_Y) ||
                                 (troop.faction === 'ai' && finalTarget._y > RIVER_Y && troop._y < RIVER_Y);
            if (needsToCross && !troop.isFlying) {
              let bridgeX = finalTarget._x < ARENA_WIDTH / 2 ? BRIDGE_LEFT_X : BRIDGE_RIGHT_X;
              const distToBridge = getDistance(troop, { _x: bridgeX, _y: RIVER_Y });
              if (distToBridge > 5) moveTarget = { _x: bridgeX, _y: RIVER_Y };
            }
            const dx = moveTarget._x - troop._x;
            const dy = moveTarget._y - troop._y;
            const dist = Math.sqrt(dx*dx + dy*dy);
            if (dist > 1) {
              troop.x += (dx/dist) * troop.speed;
              troop.y += (dy/dist) * troop.speed;
              troop._x = troop.x + 20;
              troop._y = troop.y + 20;
              troop.element.style.left = `${troop.x}px`;
              troop.element.style.top = `${troop.y}px`;
              troop.healthBarContainer.style.left = `${troop.x + 5}px`;
              troop.healthBarContainer.style.top = `${troop.y - 8}px`;
            }
          } else if (finalTarget && distance <= troop.range) {
            // ATTACK
            troop.attackCooldown--;
            if (troop.attackCooldown <= 0) {
              troop.attackCooldown = troop.attackSpeed;
              if (troop.projectileType) {
                  triggerProjectile(troop, finalTarget, troop.projectileType);
              }
              let damageDelay = troop.projectileType ? 300 : 0;
              setTimeout(() => {
                  if (finalTarget && !finalTarget.isDead) {
                      let currentDamage = troop.damage;
                      if (troop.cardName === 'Valkyrie' && troop.currentHealth < troop.maxHealth / 2) currentDamage *= 1.5;
                      finalTarget.currentHealth -= currentDamage;
                      updateHealthBar(finalTarget);
                      checkDeath(finalTarget);
                  }
              }, damageDelay);
              if (finalTarget.isDead) troop.currentTarget = null;
            }
          }
        }

        for (const towerId in towerObjects) {
          const tower = towerObjects[towerId];
          if (tower.isDead) continue;
          const targetFaction = tower.faction === 'player' ? 'ai' : 'player';
          if (tower.currentTarget) {
             const dist = getDistance(tower, tower.currentTarget);
             if (tower.currentTarget.isDead || dist > tower.range) tower.currentTarget = null;
          }
          if (!tower.currentTarget) {
            let closestDistance = tower.range;
            let newTarget = null;
            for (const troop of activeTroops) {
              if (troop.faction !== targetFaction || troop.isDead) continue;
              if (troop.isFlying && tower.attackType === 'ground') continue;
              const distance = getDistance(tower, troop);
              if (distance <= closestDistance) { newTarget = troop; closestDistance = distance; }
            }
            if (newTarget) tower.currentTarget = newTarget;
          }
          if (tower.currentTarget) {
            tower.attackCooldown--;
            if (tower.attackCooldown <= 0) {
              tower.attackCooldown = tower.attackSpeed;
              const target = tower.currentTarget;
              triggerProjectile(tower, target, 'arrow'); 
              setTimeout(() => {
                 if (target && !target.isDead) {
                     target.currentHealth -= tower.damage;
                     updateHealthBar(target);
                     checkDeath(target);
                 }
              }, 300);
              if (target.isDead) tower.currentTarget = null;
            }
          }
        }
      }

      setInterval(gameLoop, 1000 / 60);
    };
</script>
</body>
</html>
