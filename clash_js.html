<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Clash JS</title>
  <style>
    /* --- NEW Main Menu Styles --- */
    body {
      background-color: #333;
      font-family: 'Arial', sans-serif;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      overflow: hidden;
      margin: 0; /* Ensure no default margin */
    }

    /* This container will hold our "pages" */
    #app-container {
      width: 400px;
      height: 700px;
      position: relative;
    }

    #main-menu-page {
      width: 100%;
      height: 100%;
      background: linear-gradient(135deg, rgba(0,0,0,0.8), rgba(20,40,60,0.95));
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      text-align: center;
      color: #fff;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
      border: 4px solid #4a3c2a;
      border-radius: 10px;
      box-sizing: border-box; /* Include border in size */
    }

    #main-menu-page h1 {
      font-size: 48px;
      margin: 0 0 40px 0;
      font-weight: bold;
    }

    .main-menu-button {
      background: linear-gradient(#ffcc00, #e6b800);
      color: #000;
      border: none;
      padding: 15px 40px;
      font-size: 22px;
      font-weight: bold;
      border-radius: 25px;
      cursor: pointer;
      box-shadow: 0 4px 8px rgba(0,0,0,0.3);
      transition: transform 0.1s, box-shadow 0.1s;
      width: 200px; /* Give buttons a uniform width */
      margin-bottom: 20px; /* Space out buttons */
    }

    .main-menu-button:hover {
      transform: scale(1.05);
      box-shadow: 0 6px 12px rgba(0,0,0,0.4);
    }

    .main-menu-button:active {
      transform: scale(0.98);
    }

    /* Utility class to hide "pages" */
    .hidden {
      display: none;
    }


    /* --- YOUR EXISTING CSS --- */

    #game-container {
      position: relative;
      width: 100%; /* Changed from 400px to 100% to fit container */
      height: 100%; /* Changed from 700px to 100% to fit container */
      background: #5a8c3d; /* Arena grass */
      border: 4px solid #4a3c2a;
      border-radius: 10px;
      overflow: hidden;
      box-sizing: border-box; /* Add this */
    }

    /* --- Battlefield Layout --- */
    #battlefield {
      width: 100%;
      height: calc(100% - 150px); /* Leave room for elixir/cards */
      position: relative;
    }

    #river {
      position: absolute;
      width: 100%;
      height: 50px;
      background: #4a9dbe;
      top: 50%;
      transform: translateY(-50%);
      z-index: 1;
    }

    .bridge {
      position: absolute;
      width: 60px;
      height: 50px;
      background: #a17b4d;
      border-left: 5px solid #735836;
      border-right: 5px solid #735836;
      top: 50%;
      transform: translateY(-50%);
      z-index: 2;
    }
    #bridge-left { left: 40px; }
    #bridge-right { right: 40px; }

    /* --- Towers --- */
    .tower {
      position: absolute;
      width: 60px;
      height: 80px;
      background: #c9c9c9;
      border: 4px solid #777;
      border-radius: 5px 5px 0 0;
      z-index: 3;
      display: flex;
      justify-content: center;
      padding-top: 10px;
      box-sizing: border-box;
    }
    .tower::after { /* Tower roof */
      content: '';
      position: absolute;
      top: -12px;
      width: 70px;
      height: 20px;
      background: #a33e3e;
      border: 4px solid #777;
      border-radius: 5px;
    }

    /* Player Towers */
    .player-king { bottom: 20px; left: 50%; transform: translateX(-50%); }
    .player-princess { bottom: 60px; }
    #player-p1 { left: 40px; }
    #player-p2 { right: 40px; }

    /* Enemy Towers */
    .enemy-king { top: 20px; left: 50%; transform: translateX(-50%); }
    .enemy-princess { top: 60px; }
    #enemy-p1 { left: 40px; }
    #enemy-p2 { right: 40px; }

    /* --- Elixir Bar --- */
    #elixir-bar-container {
      position: absolute;
      bottom: 110px;
      width: 80%;
      left: 10%;
      height: 20px;
      background: #222;
      border-radius: 10px;
      border: 2px solid #555;
      overflow: hidden;
    }
    #elixir-bar {
      width: 50%; /* Starts at 5 */
      height: 100%;
      background: linear-gradient(to right, #e040fb, #aa00ff);
      transition: width 0.2s linear;
    }
    #elixir-count {
      position: absolute;
      top: 0;
      left: 50%;
      transform: translateX(-50%);
      color: white;
      font-weight: bold;
      line-height: 20px;
      text-shadow: 1px 1px 2px black;
    }

    /* --- Card Hand --- */
    #card-tray {
      position: absolute;
      bottom: 0;
      width: 100%;
      height: 100px;
      background: #4a3c2a;
      display: flex;
      justify-content: space-around;
      align-items: center;
      padding: 5px;
      box-sizing: border-box;
    }

    .card {
      width: 65px;
      height: 90px;
      background: white;
      border: 3px solid #fdd835;
      border-radius: 8px;
      cursor: grab;
      position: relative;
      display: flex;
      flex-direction: column;
      justify-content: flex-end; 
      align-items: center;
      padding: 0;
      box-sizing: border-box;
      font-weight: bold;
      text-align: center;
      overflow: hidden;
    }
    .card:active {
      cursor: grabbing;
      border-color: #ff0000;
    }
    .card-cost {
      position: absolute;
      top: 2px;
      left: 4px;
      font-size: 14px;
      font-weight: bold;
      background: rgba(170, 0, 255, 0.8);
      border: 2px solid rgba(255, 255, 255, 0.5);
      border-radius: 50%;
      width: 20px;
      height: 20px;
      line-height: 20px;
      text-align: center;
      color: white;
      z-index: 2;
    }
    .card-image {
      position: absolute;
      top: -5px;
      left: -15%; 
      width: 130%;
      height: auto;
      z-index: 1;
      pointer-events: none;
    }
    .card-name {
      font-size: 10px;
      z-index: 2;
      background: rgba(0, 0, 0, 0.6);
      color: white;
      width: 100%;
      padding: 2px 0;
      box-sizing: border-box;
    }


    /* --- Deployed Troop --- */
    .troop {
      position: absolute;
      width: 40px; 
      height: 40px;
      object-fit: contain; 
      z-index: 10;
      pointer-events: none;
    }

    /* --- Tower Health Bar Styles --- */
    .health-bar-container {
      position: absolute;
      width: 50px;
      height: 6px;
      background-color: #333;
      border: 1px solid black;
      border-radius: 3px;
      z-index: 11;
    }

    .health-bar-current {
      height: 100%;
      width: 100%; 
      background-color: #f44336;
      border-radius: 2px;
    }
    .health-bar-current.player {
      background-color: #4CAF50;
    }


    /* --- Troop Health Bar Styles --- */
    .troop-health-bar {
      position: absolute;
      width: 30px;
      height: 4px;
      background-color: #333;
      border: 1px solid black;
      border-radius: 2px;
      z-index: 11;
    }

    .troop-health-bar-current {
      height: 100%;
      width: 100%;
      border-radius: 1px;
    }
    .troop-health-bar-current.player {
      background-color: #4CAF50;
    }
    .troop-health-bar-current.ai {
      background-color: #f44336;
    }


    /* --- Stat Overlay Styles --- */
    #stat-overlay {
      position: absolute;
      bottom: 105px;
      left: 10px;
      width: calc(100% - 20px);
      background: rgba(0, 0, 0, 0.85);
      border: 2px solid #fdd835;
      border-radius: 8px;
      padding: 10px;
      color: white;
      z-index: 20;
      display: none;
      box-sizing: border-box;
      pointer-events: none;
    }

    #stat-overlay.visible {
      display: block;
    }

    #stat-overlay h3 {
      margin: 0 0 5px 0;
      color: #fdd835;
      font-size: 16px;
    }

    #stat-overlay p {
      margin: 4px 0;
      font-size: 12px;
    }

    /* --- No-Deploy Zone Styles --- */
    .no-deploy-zone {
      position: absolute;
      top: 0;
      height: 245px;
      background: rgba(255, 0, 0, 0.4);
      z-index: 5;
      display: none;
      pointer-events: none;
    }

    #no-deploy-zone-left {
      left: 0;
      width: 50%;
    }

    #no-deploy-zone-right {
      left: 50%;
      width: 50%;
    }

    .no-deploy-zone.visible {
      display: block;
    }

    #no-deploy-zone-king {
      top: 20px; 
      left: 170px;
      width: 60px;
      height: 80px; 
    }

    /* --- Game Menu Styles --- */
    #game-menu,
    #game-over-menu {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: linear-gradient(135deg, rgba(0,0,0,0.8), rgba(20,40,60,0.95));
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 999;
    }

    .menu-content {
      text-align: center;
      color: #fff;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
    }

    .menu-content h1 {
      font-size: 32px;
      margin: 0 0 10px 0;
      font-weight: bold;
    }

    .menu-content p {
      font-size: 18px;
      margin: 0 0 20px 0;
    }

    #play-button,
    #play-again-button {
      background: linear-gradient(#ffcc00, #e6b800);
      color: #000;
      border: none;
      padding: 15px 40px;
      font-size: 22px;
      font-weight: bold;
      border-radius: 25px;
      cursor: pointer;
      box-shadow: 0 4px 8px rgba(0,0,0,0.3);
      transition: transform 0.1s, box-shadow 0.1s;
    }

    #play-button:hover,
    #play-again-button:hover {
      transform: scale(1.05);
      box-shadow: 0 6px 12px rgba(0,0,0,0.4);
    }

    #play-button:active,
    #play-again-button:active {
      transform: scale(0.98);
    }
  </style>
</head>
<body>

  <div id="app-container">

    <div id="main-menu-page">
      <h1>Clash JS</h1>
      <button id="main-menu-play-button" class="main-menu-button">Play</button>
      <button id="main-menu-deck-button" class="main-menu-button">Deck</button>
    </div>

    <div id="game-page" class="hidden">
      <div id="game-container">
        <div id="game-menu">
          <div class="menu-content">
            <h1>Clash JS</h1>
            <p>Defeat the enemy King to win!</p>
            <button id="play-button">Play</button>
          </div>
        </div>
      
        <div id="game-over-menu" style="display: none;">
          <div class="menu-content">
            <h1 id="result-title">Victory!</h1>
            <p id="result-text">Enemy King Destroyed!</p>
            <button id="play-again-button">Play Again</button>
          </div>
        </div>
      
        <div id="battlefield">
          <div class="no-deploy-zone" id="no-deploy-zone-left"></div>
          <div class="no-deploy-zone" id="no-deploy-zone-right"></div>
          <div class="no-deploy-zone" id="no-deploy-zone-king"></div>
        
          <div class="tower enemy-king" id="enemy-king"></div>
          <div class="tower enemy-princess" id="enemy-p1"></div>
          <div class="tower enemy-princess" id="enemy-p2"></div>
        
          <div id="river"></div>
          <div class="bridge" id="bridge-left"></div>
          <div class="bridge" id="bridge-right"></div>
        
          <div class="tower player-king" id="player-king"></div>
          <div class="tower player-princess" id="player-p1"></div>
          <div class="tower player-princess" id="player-p2"></div>
        </div>
      
        <div id="elixir-bar-container">
          <div id="elixir-bar"></div>
          <span id="elixir-count">5</span>
        </div>
      
        <div id="stat-overlay">
        </div>
      
        <div id="card-tray">
          <div class="card" draggable="true" data-troop="Knight" data-cost="3">
            <span class="card-name">Knight</span>
            <span class="card-cost">3</span>
          </div>
          <div class="card" draggable="true" data-troop="Archer" data-cost="3">
            <span class="card-name">Archers</span>
            <span class="card-cost">3</span>
          </div>
          <div class="card" draggable="true" data-troop="Giant" data-cost="5">
            <span class="card-name">Giant</span>
            <span class="card-cost">5</span>
          </div>
          <div class="card" draggable="true" data-troop="Musketeer" data-cost="4">
            <span class="card-name">Musketeer</span>
            <span class="card-cost">4</span>
          </div>
          <div class="card" draggable="true" data-troop="MiniPekka" data-cost="4">
            <span class="card-name">Mini P.E.K.K.A</span>
            <span class="card-cost">4</span>
          </div>
          <div class="card" draggable="true" data-troop="Goblins" data-cost="2">
            <span class="card-name">Goblins</span>
            <span class="card-cost">2</span>
          </div>
          <div class="card" draggable="true" data-troop="Valkyrie" data-cost="4">
            <span class="card-name">Valkyrie</span>
            <span class="card-cost">4</span>
          </div>
          <div class="card" draggable="true" data-troop="BabyDragon" data-cost="4">
            <span class="card-name">Baby Dragon</span>
            <span class="card-cost">4</span>
          </div>
        </div>
      </div>
    </div>

  </div> <script>
    // We will put ALL logic inside window.onload
    // to ensure every single element is ready.
    window.onload = function() {

      // --- TEST #1 ---
      // This alert MUST appear when you load the page.
      // If it doesn't, the new script is not loading (caching).
      alert("Clash JS script is running!");

      // --- NEW MAIN MENU LOGIC ---
      const mainMenuPage = document.getElementById('main-menu-page');
      const gamePage = document.getElementById('game-page');
      const mainMenuPlayButton = document.getElementById('main-menu-play-button');
      const mainMenuDeckButton = document.getElementById('main-menu-deck-button');

      if (mainMenuPlayButton) {
        mainMenuPlayButton.addEventListener('click', () => {
          mainMenuPage.classList.add('hidden');
          gamePage.classList.remove('hidden');
        });
      }

      if (mainMenuDeckButton) {
        mainMenuDeckButton.addEventListener('click', () => {
          mainMenuDeckButton.textContent = 'Coming Soon!';
          setTimeout(() => {
            mainMenuDeckButton.textContent = 'Deck';
          }, 2000);
        });
      }

      // --- YOUR EXISTING MENU LOGIC ---
      const gameMenu = document.getElementById('game-menu');
      const playButton = document.getElementById('play-button'); // This is the IN-GAME play button
      const gameOverMenu = document.getElementById('game-over-menu');
      const playAgainButton = document.getElementById('play-again-button');

      if (gameOverMenu && playAgainButton) {
        playAgainButton.addEventListener('click', () => {
          location.reload(); 
        });
      }

      // --- YOUR EXISTING GAME SCRIPT ---
      const battlefield = document.getElementById('battlefield');
      const cards = document.querySelectorAll('.card');
      const elixirBar = document.getElementById('elixir-bar');
      const elixirCount = document.getElementById('elixir-count');
      const statOverlay = document.getElementById('stat-overlay');
      const noDeployLeft = document.getElementById('no-deploy-zone-left');
      const noDeployRight = document.getElementById('no-deploy-zone-right');
      const noDeployKing = document.getElementById('no-deploy-zone-king');
      const menuTitle = gameMenu.querySelector('h1');
      const menuSubtitle = gameMenu.querySelector('p');

      // --- Troop Database ---
      const TROOP_DATA = {
        Knight: {
          cost: 3,
          imageUrl: 'https://i.postimg.cc/qM5Cfg8Z/download.jpg',
          speed: 0.6,
          health: 660,
          damage: 75,
          attackSpeed: 70,
          range: 10,
          targetType: 'any',
          attackType: 'ground',
        },
        Archer: {
          cost: 3,
          imageUrl: 'https://i.postimg.cc/1XWV33bS/download-(1).jpg',
          speed: 0.5,
          health: 120,
          damage: 40,
          attackSpeed: 60,
          range: 100,
          targetType: 'any',
          attackType: 'airAndGround',
        },
        Giant: {
          cost: 5,
          imageUrl: 'https://i.postimg.cc/3xkmW28w/download-(2).jpg',
          speed: 0.3,
          health: 1500,
          damage: 100,
          attackSpeed: 90,
          range: 10,
          targetType: 'buildings',
          attackType: 'ground',
        },
        Musketeer: {
          cost: 4,
          imageUrl: 'https://i.postimg.cc/TP4R1WPX/download-(8).jpg',
          speed: 0.5,
          health: 300,
          damage: 90,
          attackSpeed: 60,
          range: 120,
          targetType: 'any',
          attackType: 'airAndGround',
        },
        MiniPekka: {
          cost: 4,
          imageUrl: 'https://i.postimg.cc/d3JG0X1j/download-(4).jpg',
          speed: 0.7,
          health: 500,
          damage: 250,
          attackSpeed: 100,
          range: 10,
          targetType: 'any',
          attackType: 'ground',
        },
        Goblins: {
          cost: 2,
          imageUrl: 'https://i.postimg.cc/XYPKgQHf/download-(5).jpg',
          speed: 0.9,
          health: 80,
          damage: 45,
          attackSpeed: 40,
          range: 10,
          targetType: 'any',
          attackType: 'ground',
        },
        Valkyrie: {
          cost: 4,
          imageUrl: 'https://i.postimg.cc/9FWBX4w5/download-(6).jpg',
          speed: 0.6,
          health: 700,
          damage: 100,
          attackSpeed: 80,
          range: 10,
          targetType: 'any',
          attackType: 'ground',
        },
        BabyDragon: {
          cost: 4,
          imageUrl: 'https://i.postimg.cc/KjGHB0jc/download-(7).jpg',
          speed: 0.5,
          health: 600,
          damage: 60,
          attackSpeed: 70,
          range: 80,
          targetType: 'any',
          attackType: 'airAndGround',
          isFlying: true,
        },
      };

      // --- Game State ---
      let currentElixir = 5;
      let aiElixir = 5;
      const maxElixir = 10;
      const elixirRegenRate = 2000;
      let draggedCardData = null;
      let activeTroops = [];
      let towerObjects = {};
      const aiDeck = [
        'Knight',
        'Archer',
        'Giant',
        'Goblins',
        'Musketeer',
        'BabyDragon',
      ];
      let gameRunning = false;
      let elixirInterval = null;
      let aiInterval = null;

      // --- Arena Layout Constants ---
      const ARENA_WIDTH = 400;
      const RIVER_Y = 245;
      const BRIDGE_LEFT_X = 70;
      const BRIDGE_RIGHT_X = 330;
      const PLAYER_TOWER_LEFT_X = 40;
      const PLAYER_TOWER_RIGHT_X = 300;
      const PLAYER_TOWER_Y = 400;
      const PLAYER_KING_X = 170;
      const PLAYER_KING_Y = 460;
      const ENEMY_TOWER_LEFT_X = 40;
      const ENEMY_TOWER_RIGHT_X = 300;
      const ENEMY_TOWER_Y = 60;
      const ENEMY_KING_X = 170;
      const ENEMY_KING_Y = 20;

      // --- Elixir Generation ---
      function updateElixirDisplay() {
        elixirCount.textContent = Math.floor(currentElixir);
        elixirBar.style.width = `${(currentElixir / maxElixir) * 100}%`;
      }

      // --- Stat Helper Functions ---
      function getSpeedCategory(speed) {
        if (speed < 0.4) return 'Slow';
        if (speed < 0.6) return 'Medium';
        if (speed < 0.8) return 'Fast';
        return 'Very Fast';
      }

      function getDistance(unitA, unitB) {
        const ax = unitA._x || unitA.x;
        const ay = unitA._y || unitA.y;
        const bx = unitB._x || unitB.x;
        const by = unitB._y || unitB.y;
        const dx = ax - bx;
        const dy = ay - by;
        return Math.sqrt(dx * dx + dy * dy);
      }

      // --- Drag and Drop Logic ---
      cards.forEach((card) => {
        card.addEventListener('dragstart', (e) => {
          if (!gameRunning) return;

          if (!towerObjects['enemy-p1'].isDead) {
            noDeployLeft.classList.add('visible');
          }
          if (!towerObjects['enemy-p2'].isDead) {
            noDeployRight.classList.add('visible');
          }
          noDeployKing.classList.add('visible');

          draggedCardData = {
            troop: e.target.dataset.troop,
            cost: parseInt(e.target.dataset.cost, 10),
          };
          e.dataTransfer.setData('text/plain', e.target.dataset.troop);
        });

        card.addEventListener('dragend', (e) => {
          noDeployLeft.classList.remove('visible');
          noDeployRight.classList.remove('visible');
          noDeployKing.classList.remove('visible');
        });

        card.addEventListener('mouseover', (e) => {
          const troopName = e.currentTarget.dataset.troop;
          const data = TROOP_DATA[troopName];
          if (!data) return;
          statOverlay.innerHTML = `
            <h3>${troopName}</h3>
            <p><b>Health:</b> ${data.health}</p>
            <p><b>Damage:</b> ${data.damage}</p>
            <p><b>Speed:</b> ${getSpeedCategory(data.speed)}</p>
          `;
          statOverlay.classList.add('visible');
        });
        card.addEventListener('mouseout', (e) => {
          statOverlay.classList.remove('visible');
        });
      });

      battlefield.addEventListener('dragover', (e) => e.preventDefault());

      // --- Battlefield Drop Logic ---
      battlefield.addEventListener('drop', (e) => {
        e.preventDefault();

        noDeployLeft.classList.remove('visible');
        noDeployRight.classList.remove('visible');
        noDeployKing.classList.remove('visible');

        if (!gameRunning || !draggedCardData) return;

        if (currentElixir >= draggedCardData.cost) {
          const rect = battlefield.getBoundingClientRect();
          const x = e.clientX - rect.left;
          const y = e.clientY - rect.top;

          const kingTowerWidth = 60;
          const kingTowerHeight = 80;
          let isOverKingTower =
            x >= ENEMY_KING_X &&
            x <= ENEMY_KING_X + kingTowerWidth &&
            y >= ENEMY_KING_Y &&
            y <= ENEMY_KING_Y + kingTowerHeight;

          if (isOverKingTower) {
            console.warn('Cannot deploy directly on the King Tower!');
            draggedCardData = null;
            return;
          }

          const isLeftLane = x < ARENA_WIDTH / 2;
          const isEnemyTerritory = y < RIVER_Y;
          let canDeploy = true;

          if (isEnemyTerritory) {
            if (isLeftLane && !towerObjects['enemy-p1'].isDead) {
              canDeploy = false;
            } else if (!isLeftLane && !towerObjects['enemy-p2'].isDead) {
              canDeploy = false;
            }
          }

          if (canDeploy) {
            currentElixir -= draggedCardData.cost;
            updateElixirDisplay();
            deployTroop(draggedCardData.troop, x, y, 'player');
          } else {
            console.warn(
              'Cannot deploy there! Take the Princess Tower on this lane first.',
            );
          }
        } else {
          console.warn('Not enough elixir!');
        }
        draggedCardData = null;
      });

      // --- Initialize Towers ---
      function initializeTowers() {
        const towerElements = [
          {
            id: 'enemy-p1',
            faction: 'ai',
            element: document.getElementById('enemy-p1'),
            x: ENEMY_TOWER_LEFT_X,
            y: ENEMY_TOWER_Y,
            maxHealth: 1400,
            damage: 50,
            range: 150,
            attackSpeed: 60,
            attackType: 'airAndGround',
          },
          {
            id: 'enemy-p2',
            faction: 'ai',
            element: document.getElementById('enemy-p2'),
            x: ENEMY_TOWER_RIGHT_X,
            y: ENEMY_TOWER_Y,
            maxHealth: 1400,
            damage: 50,
            range: 150,
            attackSpeed: 60,
            attackType: 'airAndGround',
          },
          {
            id: 'enemy-king',
            faction: 'ai',
            element: document.getElementById('enemy-king'),
            x: ENEMY_KING_X,
            y: ENEMY_KING_Y,
            maxHealth: 2400,
            damage: 60,
            range: 130,
            attackSpeed: 70,
            attackType: 'airAndGround',
          },
          {
            id: 'player-p1',
            faction: 'player',
            element: document.getElementById('player-p1'),
            x: PLAYER_TOWER_LEFT_X,
            y: PLAYER_TOWER_Y,
            maxHealth: 1400,
            damage: 50,
            range: 150,
            attackSpeed: 60,
            attackType: 'airAndGround',
          },
          {
            id: 'player-p2',
            faction: 'player',
            element: document.getElementById('player-p2'),
            x: PLAYER_TOWER_RIGHT_X,
            y: PLAYER_TOWER_Y,
            maxHealth: 1400,
            damage: 50,
            range: 150,
            attackSpeed: 60,
            attackType: 'airAndGround',
          },
          {
            id: 'player-king',
            faction: 'player',
            element: document.getElementById('player-king'),
            x: PLAYER_KING_X,
            y: PLAYER_KING_Y,
            maxHealth: 2400,
            damage: 60,
            range: 130,
            attackSpeed: 70,
            attackType: 'airAndGround',
          },
        ];

        towerElements.forEach((towerData) => {
          const healthBarContainer = document.createElement('div');
          healthBarContainer.className = 'health-bar-container';
          healthBarContainer.style.left = `${towerData.x + 5}px`;
          healthBarContainer.style.top = `${towerData.y - 15}px`;

          const healthBarCurrent = document.createElement('div');
          healthBarCurrent.className = `health-bar-current ${towerData.faction}`;

          healthBarContainer.appendChild(healthBarCurrent);
          battlefield.appendChild(healthBarContainer);

          towerObjects[towerData.id] = {
            ...towerData,
            currentHealth: towerData.maxHealth,
            _x: towerData.x + 30, // Center X
            _y: towerData.y + 40, // Center Y
            healthBar: healthBarCurrent,
            healthBarContainer: healthBarContainer,
            isDead: false,
            attackCooldown: 0,
            currentTarget: null,
          };
        });
      }

      // --- Initialize Card Images ---
      function initializeCards() {
        cards.forEach((card) => {
          const troopName = card.dataset.troop;
          if (!troopName) return; 
          const data = TROOP_DATA[troopName];
          if (!data) return;

          const existingImage = card.querySelector('.card-image');
          if (existingImage) return; 

          const img = document.createElement('img');
          img.src = data.imageUrl;
          img.classList.add('card-image');

          card.prepend(img);
        });
      }

      // --- Deploy Troop Function ---
      function deployTroop(troopName, x, y, faction) {
        const troopData = TROOP_DATA[troopName];
        if (!troopData) return;

        const troopElement = document.createElement('img');
        troopElement.classList.add('troop');
        troopElement.src = troopData.imageUrl;

        let startX = x - 20;
        let startY = y - 20;
        troopElement.style.left = `${startX}px`;
        troopElement.style.top = `${startY}px`;

        const healthBarContainer = document.createElement('div');
        healthBarContainer.className = 'troop-health-bar';
        healthBarContainer.style.left = `${startX + 5}px`;
        healthBarContainer.style.top = `${startY - 8}px`;
        const healthBarCurrent = document.createElement('div');
        healthBarCurrent.className = `troop-health-bar-current ${faction}`;
        healthBarContainer.appendChild(healthBarCurrent);

        let defaultTargetTower, finalTarget;
        const enemyFaction = faction === 'player' ? 'ai' : 'player';

        if (faction === 'player') {
          finalTarget = towerObjects['enemy-king'];
          defaultTargetTower =
            x < ARENA_WIDTH / 2
              ? towerObjects['enemy-p1']
              : towerObjects['enemy-p2'];
        } else {
          // Faction is 'ai'
          finalTarget = towerObjects['player-king'];
          defaultTargetTower =
            x < ARENA_WIDTH / 2
              ? towerObjects['player-p1']
              : towerObjects['player-p2'];
        }

        battlefield.appendChild(troopElement);
        battlefield.appendChild(healthBarContainer);

        const troop = {
          ...troopData,
          troopName: troopName,
          element: troopElement,
          faction: faction,
          x: startX,
          y: startY,
          _x: startX + 20,
          _y: startY + 20,
          attackCooldown: 0,
          maxHealth: troopData.health,
          currentHealth: troopData.health,
          healthBar: healthBarCurrent,
          healthBarContainer: healthBarContainer,
          isDead: false,
          currentTarget: null,
          defaultTargetTower: defaultTargetTower,
          finalTarget: finalTarget,
        };
        activeTroops.push(troop);
      }

      // --- Find New Target Function ---
      function findNewTarget(troop) {
        const enemyFaction = troop.faction === 'player' ? 'ai' : 'player';
        const enemyPrefix = troop.faction === 'player' ? 'enemy' : 'player';

        let closestTarget = null;
        let minDistance = 9999;

        // 1. Building-only troops (Giant)
        if (troop.targetType === 'buildings') {
          let targets = [
            towerObjects[`${enemyPrefix}-p1`],
            towerObjects[`${enemyPrefix}-p2`],
            towerObjects[`${enemyPrefix}-king`],
          ];
          let closestTower = null;

          for (const tower of targets) {
            if (tower && !tower.isDead) {
              const dist = getDistance(troop, tower);
              if (dist < minDistance) {
                minDistance = dist;
                closestTower = tower;
              }
            }
          }
          troop.currentTarget = closestTower;
          return;
        }

        // 2. "Any" type troops (Knight, Archer, etc.)
        minDistance = 9999;

        // Scan troops
        for (const t of activeTroops) {
          if (t.faction === enemyFaction && !t.isDead) {
            if (t.isFlying && troop.attackType === 'ground') {
              continue;
            }
            const dist = getDistance(troop, t);
            if (dist < minDistance) {
              minDistance = dist;
              closestTarget = t;
            }
          }
        }

        // Scan towers
        let targets = [
          towerObjects[`${enemyPrefix}-p1`],
          towerObjects[`${enemyPrefix}-p2`],
          towerObjects[`${enemyPrefix}-king`],
        ];
        for (const tower of targets) {
          if (tower && !tower.isDead) {
            const dist = getDistance(troop, tower);
            if (dist < minDistance) {
              minDistance = dist;
              closestTarget = tower;
            }
          }
        }

        troop.currentTarget = closestTarget;
      }

      // --- Game Control Functions ---
      function resetGame() {
        gameRunning = false;
        if (elixirInterval) clearInterval(elixirInterval);
        if (aiInterval) clearInterval(aiInterval);
        elixirInterval = null;
        aiInterval = null;

        activeTroops.forEach((troop) => {
          troop.element.remove();
          troop.healthBarContainer.remove();
        });
        activeTroops = [];

        if (Object.keys(towerObjects).length > 0) {
          Object.values(towerObjects).forEach((tower) => {
            if (tower.healthBarContainer) {
              tower.healthBarContainer.remove();
            }
          });
        }
        
        towerObjects = {};
        currentElixir = 5;
        aiElixir = 5;
      }

      function endGame(message) {
        gameRunning = false;
        if (elixirInterval) clearInterval(elixirInterval);
        if (aiInterval) clearInterval(aiInterval);

        const resultTitle = document.getElementById('result-title');
        const resultText = document.getElementById('result-text');
        const gameOverMenu = document.getElementById('game-over-menu');

        if (message === 'You Win!') {
          resultTitle.textContent = 'Victory!';
          resultText.textContent = 'Enemy King Destroyed!';
        } else {
          resultTitle.textContent = 'Defeat!';
          resultText.textContent = 'Your King Destroyed!';
        }

        gameOverMenu.style.display = 'flex'; 
        resetGame();
      }

      function startGame() {
        
        // --- TEST #2 ---
        // This alert MUST appear when you click the in-game "Play" button.
        // If it doesn't, the button is not connected.
        alert("Start button clicked!");

        gameRunning = true;
        gameMenu.style.display = 'none'; 
        updateElixirDisplay();
        initializeTowers(); 

        elixirInterval = setInterval(() => {
          if (!gameRunning) return;
          if (currentElixir < maxElixir) {
            currentElixir += 1;
            if (currentElixir > maxElixir) currentElixir = maxElixir;
            updateElixirDisplay();
          }
          if (aiElixir < maxElixir) {
            aiElixir += 1;
            if (aiElixir > maxElixir) aiElixir = maxElixir;
          }
        }, elixirRegenRate);

        aiInterval = setInterval(() => {
          if (!gameRunning) return;
          const cardName = aiDeck[Math.floor(Math.random() * aiDeck.length)];
          const cardCost = TROOP_DATA[cardName].cost;

          if (aiElixir >= cardCost) {
            aiElixir -= cardCost;
            let deployX = Math.random() > 0.5 ? 100 : 300;
            let deployY = 120; // Deploy at the back
            deployTroop(cardName, deployX, deployY, 'ai');
          }
        }, 3000);

        gameLoop();
      }

      // --- Game Loop ---
      function gameLoop() {
        if (!gameRunning) return; 

        // 1. Dead Unit Cleanup
        for (let i = activeTroops.length - 1; i >= 0; i--) {
          const troop = activeTroops[i];
          if (troop.isDead) {
            troop.element.remove();
            troop.healthBarContainer.remove();
            activeTroops.splice(i, 1);
          }
        }
      
        // 2. Troop Logic
        for (const troop of activeTroops) {
          if (
            troop.targetType === 'any' ||
            !troop.currentTarget ||
            troop.currentTarget.isDead
          ) {
            findNewTarget(troop);
            if (!troop.currentTarget) continue;
          }

          const finalTarget = troop.currentTarget;
          if (!finalTarget) continue;

          const distance = getDistance(troop, finalTarget);

          if (distance > troop.range) {
            // Move
            let moveTarget = finalTarget;
            const needsToCross =
              (troop.faction === 'player' &&
                finalTarget._y < RIVER_Y &&
                troop._y > RIVER_Y) ||
              (troop.faction === 'ai' &&
                finalTarget._y > RIVER_Y &&
                troop._y < RIVER_Y);

            if (needsToCross && !troop.isFlying) {
              let bridgeX =
                finalTarget._x < ARENA_WIDTH / 2 ? BRIDGE_LEFT_X : BRIDGE_RIGHT_X;
              const bridgeTarget = { _x: bridgeX, _y: RIVER_Y };
              const distToBridge = getDistance(troop, bridgeTarget);
              if (distToBridge > 5) {
                moveTarget = bridgeTarget;
              }
            }

            const dx = moveTarget._x - troop._x;
            const dy = moveTargt._y - troop._y;
            const distToMoveTarget = Math.sqrt(dx * dx + dy * dy);

            if (distToMoveTarget > 1) {
              troop.x += (dx / distToMoveTarget) * troop.speed;
              troop.y += (dy / distToMoveTarget) * troop.speed;
              troop._x = troop.x + 20;
              troop._y = troop.y + 20;

              troop.element.style.left = `${troop.x}px`;
              troop.element.style.top = `${troop.y}px`;
              troop.healthBarContainer.style.left = `${troop.x + 5}px`;
              troop.healthBarContainer.style.top = `${troop.y - 8}px`;
            }
          } else {
            // Attack
            troop.attackCooldown--;
            if (troop.attackCooldown <= 0) {
              troop.attackCooldown = troop.attackSpeed;

              let currentDamage = troop.damage;
              if (
                troop.troopName === 'Valkyrie' &&
                troop.currentHealth < troop.maxHealth / 2
              ) {
                currentDamage *= 1.5;
              }

              finalTarget.currentHealth -= currentDamage;

              const healthPercent =
                (finalTarget.currentHealth / finalTarget.maxHealth) * 100;
              finalTarget.healthBar.style.width = `${Math.max(0, healthPercent)}%`;

              if (finalTarget.currentHealth <= 0 && !finalTarget.isDead) {
                finalTarget.isDead = true;
                troop.currentTarget = null;

                if (finalTarget.id && finalTarget.id.includes('-king')) {
                  const message =
                    troop.faction === 'player' ? 'You Win!' : 'You Lose!';
                  endGame(message);
                  return; 
                }
              }
            }
          }
        }

        // 3. Tower Logic
        for (const towerId in towerObjects) {
          const tower = towerObjects[towerId];
          if (tower.isDead) continue;

          const targetFaction = tower.faction === 'player' ? 'ai' : 'player';

          if (tower.currentTarget) {
            const dist = getDistance(tower, tower.currentTarget);
            if (tower.currentTarget.isDead || dist > tower.range) {
              tower.currentTarget = null;
            }
          }

          if (!tower.currentTarget) {
            let closestDistance = tower.range;
            let newTarget = null;
            for (const troop of activeTroops) {
              if (troop.faction !== targetFaction || troop.isDead) continue;
              if (troop.isFlying && tower.attackType === 'ground') {
                continue;
              }
              const distance = getDistance(tower, troop);
              if (distance <= closestDistance) {
                newTarget = troop;
                closestDistance = distance;
              }
            }
            if (newTarget) {
              tower.currentTarget = newTarget;
            }
          }

          if (tower.currentTarget) {
            tower.attackCooldown--;
            if (tower.attackCooldown <= 0) {
              tower.attackCooldown = tower.attackSpeed;
              const target = tower.currentTarget;
              target.currentHealth -= tower.damage;

              const healthPercent = (target.currentHealth / target.maxHealth) * 100;
              target.healthBar.style.width = `${Math.max(0, healthPercent)}%`;

              if (target.currentHealth <= 0) {
                target.isDead = true;
                tower.currentTarget = null;
              }
            }
          } else {
            tower.attackCooldown = 0;
          }
        }

        // Loop
        if (gameRunning) {
          try {
            requestAnimationFrame(gameLoop);
          } catch (e) {
            console.error('Critical error in gameLoop, stopping game.', e);
            endGame('Critical Error!');
          }
        }
      }

      // --- Initialize Page ---
      updateElixirDisplay();
      initializeCards(); 

      // --- ATTACH BUTTON LISTENERS ---
      playButton.addEventListener('click', startGame);

    }; // --- END OF window.onload WRAPPER ---
  </script>
</body>
</html>
